# Наследование и композиция вместе с Polymer

Вы наверное уже слышали про эту новую крутую штуковину, которая изменит всё
представление о построении веб-приложений, верно? Да, я говорю о
[Web Components][1]. Web Components — это новая технология, которая позволит нам
создавать собственные компоненты для веб, с помощью инструментов, которые
используют разработчики браузеров.

На самом деле, Web Components представляет собой набор из четырех спецификаций.
Это *HTML Imports*, *HTML Templates*, *Custom Elements* и *Shadow DOM*. Я не
буду подробно о них рассказывать, так как статья не об этом. Если вы хотите
узнать больше о веб-компонентах в целом, я рекомендую обратить внимание на
сообщество [webcomponents.org][1], в котором много полезных ресурсов и
информации о технологиях.

С развитием стандартов приходит развитие инструментов, библиотек и фреймворков.
Когда дело доходит до веб-компонентов, на помощь приходят два фреймворка,
которые пытаются сделать вашу жизнь лучше: [X-Tag][2] от Mozilla и [Polymer][3]
от Google. *Оба под капотом используют одни и те-же полифиллы* для совместимости
со всеми основными версиями браузеров. Однако, X-Tag предоставляет только
императивный способ создания компонентов, в то время как Polymer идет дальше,
предоставляя так-же и декларативный стиль.

Например  определение собственных элементов с помощью Polymer выглядит так:

    <polymer-element name="my-custom-element" noscript>
      <template>
        <!-- shadow dom -->
        <div>Мой элемент</div>
      </template>
    </polymer-element>

Все что нужно для использования созданного элемента — это импортировать его:

    <!-- import custom element -->
    <link rel="import" href="path/to/my-custom-element.html">

    <my-custom-element></my-custom-element>

Это все, что нужно для создания собственных элементов с помощью Polymer.
Заглянув в глубь того, что здесь происходит, мы можем увидеть все четыре
технологии в действии. Мы создали элемент (регистрация его в DOM происходит за
кулисами, Polymer позаботится об этом). Мы определяем HTML шаблон для нашего
элемента, который впоследствии будет использован в Shadow DOM. И в заключение,
для использования элемента, мы импортируем его.

Конечно  возможностей в мире Polymer намного больше. Я рекомендую почитать
[документацию][4] чтобы узнать их все.

## Расширение существующих элементов

Одной из самых больших вещей, что приносят Web Components, является тот факт,
что вы можете расширять существующие элементы. И так как созданные вами
компоненты являются простыми HTML элементами, вы можете расширять их точно так-
же, как и нативные элементы. С поверхностной точки зрения нет никакой разницы
между пользовательскими и встроенными элементами.

Давайте посмотрим, как мы можем расширить существующие элементы. Расширять
элементы Polymer предлагает декларативным способом, через HTML. Просто
используйте атрибут `extends`, в значении которого нужно указать имя
расширяемого элемента.

Но прежде чем приступить к делу давайте создадим какой-нибудь более полезный
элемент. Вот определение элемента `basic-button`:

    <polymer-element name="basic-button" noscript>
      <template>
        <span><content></content></span>
      </template>
    </polymer-element>

Нововведением здесь является использование элемента `<content>`. С помощью него
определяются так называемые «точки вставки». Точки это место в вашем Shadow DOM,
где будет находится содержание, используемого в текущий момент, элемента.
Используем наш `basic-button`:

    <basic-button>Hello</basic-button>

В результате, Shadow DOM будет выглядеть так:

    <span>Hello</span>

Если вы знакомы с [AngularJS][5], точка вставки — это что-то вроде
`ngTransclude`. Точки вставки, на самом деле, идут дальше, но сейчас я не буду
вдаваться в подробности.

Хорошо  теперь давайте расширим элемент `basic-button`. Наша цель получить
кнопку с иконкой, так что новый элемент будет называться `icon-button`, а
атрибут `extends` будет указывать на существующий элемент `basic-button`.

    <polymer-element name="icon-button" extends="basic-button">
      <template>
        <span>
          <i class="icon"></i><shadow></shadow>
        </span>
      </template>
      <script>
        Polymer('icon-button');
      </script>
    </polymer-element>

В этом фрагменте есть несколько новых приёмов, давайте рассмотрим их
внимательнее. Во первых, это `<shadow>` элемент. `<shadow>` — очень мощный, так
как он может расширить Shadow DOM вашего элемента вместе с содержимым
родительского Shadow DOM.

Мы так-же используем конструктор `Polymer`, чтобы явно зарегистрировать наш
пользовательский элемент (через минуту мы поймем, зачем).

Осталось вызвать наш расширенный элемент:

    <icon-button>Hello</icon-button>

В зависимости от ваших требований, вы можете использовать `is=""` синтаксис, для
расширения существующих элементов в коде приложения. Просто запомните, что
`is=""` работает только для нативных элементов. Поэтому, вместо использования
кастомного тега элемента можно написать что-то вроде:

    <button is="mega-button"></button>

Опять-же, это зависит от ваших задач.

Если существует дополнительный функционал, который вы хотели бы реализовать,
например, обратный вызов `ready`, вы можете определить его в конструкторе. А
чтобы быть уверенным в том, что обратный вызов в родительском элементе сработал,
можно вызвать `this.super()`:

    Polymer('icon-button', {
      ready: function () {
        // выполняется, когда компонент будет готов
        console.log('icon-button ready');

        // вызываем родительский `ready`
        this.super();
      }
    });

Вы так-же можете переопределять существующие методы и получать доступ к
свойствам с привязкой данных. Любопытно, как? Подробнее можно почитать
[здесь][6].

## Расширение нескольких элементов

Теперь мы знаем, как расширять элементы с помощью Polymer, при этом вы могли бы
задаться вопросом, как можно расширить несколько элементов. Например, у нас есть
компонент, расширяющий элементы таким образом, чтобы их можно было таскать
мышкой. Мы могли бы использовать его, применяя к существующим элементам, таким
как этот:

    <!-- перетаскиваемый img -->
    <img is="my-draggable">

    <!-- перетаскиваемое что-то другое -->
    <div is="my-draggable"></div>

Так как-же расширить несколько элементов? Вы наверняка ждете решения в духе
`extends="foo bar"`, верно? К сожалению, решения нет. Чтобы сделать его более
понятным:

**Невозможно расширить несколько элементов**

Вы не найдете ничего в официальной документации, а так-же можете прочесть об
этом в [вопросе на StackOverflow][7]. Однако, есть несколько способов получить
*несколько* результатов, когда речь заходит о расширении множества элементов.

## Композиция вместо наследования

На первый взгляд, всегда лучше использовать композицию вместо наследование, дабы
сохранить гибкость. Так что, вместо явного объявления элементов, расширяющих
другие элементы, для повторного использования функционала лучшим решением будет
**собирать** новые элементы из уже существующих.

Так мы могли взять элемент `icon-button` и разбить его на три более мелких
элемента, с помощью композиции. Например, мы могли бы получить элементы 
`basic-icon`, `basic-button` и `icon-button`. Они не расширяют `basic-button`, но
используют его Shadow DOM. Затем мы могли бы определить элемент `icon-link`,
использующий `basic-icon` и какой-нибудь `basic-link` (или что вам в придет
голову).

Чтобы получить представление о том, как сильно можно сломать суть вещей, просто
взгляните на [Polymer Paper Elements][8]. Еще один проект, на который стоит
обратить внимание, это [Basic Web Components][9]. Этот проект диктует основные
принципы, в основном, основанные на композиции.

## Повторное использование функциональности с помощью миксинов

Теперь  даже если мы в состоянии собрать новые элементы из существующих, бывают
случаи, когда действительно хочется повторно использовать существующую
функциональность. Просто подумайте о примере с `my-draggable`. Возможность
перетаскивания элемента мышкой — это не про создание нового элемента из
существующих, а, скорее, про совместное использование функционала несколькими
элементами.

Можно ли это сделать с помощью Polymer? Да, можно. Polymer поддерживает миксины.
С миксинами мы можем расширять существующие компоненты общим функционалом, без
явного расширения других элементов. Всё, что нам нужно — это изолировать общую
функциональность и примешивать её в конструктор наших компонентов используя
`Platform.mixin()`. Объект `Platform` доступен глобально, если Polymer
подключен, поскольку он поставляется вместе с Polymer по умолчанию.

Например  скажем, что у нас есть миксин, обеспечивающий общую функциональность
для нескольких объектов:

  var sharedMixin = {
    // определяем общие функции и свойства
  };

Просто чистый JavaScript. Теперь, для повторного использования функционала, всё,
что потребуется сделать, это расширить конструктор нашего компонента используя
`Platform.mixin()` следующим образом:

  Polymer('my-component', Platform.mixin({
    // логика компонента
  }, sharedMixin));

## Общие миксины для нескольких импортов

Силой Web Components не составляет труда сделать миксины доступными для
нескольких импортированных элементов. Даже если термин «Web Components» звучит
супер-сложно, это всё ещё HTML, CSS и JavaScript. Те-же инструменты, те-же
правила.

Так что, если нужно сделать миксин доступным глобально для нескольких
импортированных элементов, всё, что нам нужно сделать, это положить общие
миксины в отдельный документ, который ничего не делает, но определяет миксины в
глобальном пространстве имен. Наш `shared.html` может выглядеть примерно так:

    <script>
      window.sharedMixin = {
        // логика компонента
      };
    </script>

И благодаря HTML Imports, можно просто импортировать его в наши компоненты, как
мы делали это с другими полноценными компонентами:

    <link rel="import" href="path/to/shared.html">

    <element name="foo-element">
      <script>
        Polymer('foo-element', Platform.mixin({
          // логика компонента
        }, sharedMixin));
      </script>
    </element>

(Поскольку я изо всех сил боролся именно с этой проблемой, я включил сюда часть
моего [вопроса с StackOverflow][10].)

 [1]: http://webcomponents.org/
 [2]: http://www.x-tags.org/
 [3]: http://polymer-project.org
 [4]: http://www.polymer-project.org/docs/polymer/polymer.html
 [5]: http://angularjs.org
 [6]: http://www.polymer-project.org/docs/polymer/polymer.html#extending-other-elements
 [7]: http://stackoverflow.com/questions/24157576/how-to-extend-multiple-elements-with-polymer
 [8]: https://github.com/Polymer?query=paper
 [9]: https://github.com/basic-web-components/
 [10]: http://stackoverflow.com/questions/24180622/is-it-possible-to-share-mixins-across-web-components-and-imports-in-polymer
